---------------------------------------------------------------------------------------
---   smoke detector P.A.T.R.I.C.K. STAR  v0.2                                      ---
---   authors: Vitalij Kagadij, Lotte Steenbrink, Jan Strothmann, Matthies Becker   ---
---------------------------------------------------------------------------------------

max = 2
datatype SIGNAL = SMOKE | NO_SMOKE | POLL | RESET | DEFECT
channel comm : {0..max}.SIGNAL
channel alert

CONTROLLER(x) = (x > max)& CONTROLLER(0)
       []
       (x <= max)&comm!x.POLL -> ((comm?x.NO_SMOKE -> CONTROLLER(x+1)) [] (comm?x.SMOKE -> ALERT(x)) [] (comm?x.DEFECT -> CONTROLLER(x+1)))

	  
ALERT(x) = alert -> comm!x.RESET -> CONTROLLER(x+1)
	  
SENSOR(x, STATE) = (comm.x?POLL -> if (STATE == NO_SMOKE) -- on poll: determine state, return it to controller and persist it via recursion 
                                   then ((comm!x.NO_SMOKE -> SENSOR(x, NO_SMOKE)) |~| (comm!x.SMOKE -> SENSOR(x, SMOKE)) |~| (comm!x.DEFECT -> SENSOR(x, DEFECT)))
                                   else comm!x.STATE -> SENSOR(x, STATE))
                   [] 
			       (comm.x?RESET -> if (STATE == SMOKE) then SENSOR(x, NO_SMOKE) |~| SENSOR(x, SMOKE) -- internal choice for error on reset
				                    else SENSOR(x, STATE))
	   
--- concrete system --- 
SYS = CONTROLLER(0) [|{| comm |}|] (||| i:{ 0..max } @ SENSOR(i, NO_SMOKE))

-------------
--- Tests --- 
-------------

--- channels for tests only --- 
channel poll, no_smoke, error, smoke, defect

SYS_HIDDEN = 
   SYS[[ comm.x.POLL <- poll, comm.x.NO_SMOKE <- no_smoke, comm.x.DEFECT <- defect | x <- {0..max} ]] 

SYS_HIDDEN2 = 
   SYS[[ comm.x.POLL <- poll, comm.x.SMOKE <- smoke | x <- {0..max} ]] 
   
   
--- test specification ---
SPEC = comm?x.SMOKE -> alert -> comm.x?RESET -> SPEC

--- tests if the specified behaviour is possible in concrete system ---
assert SYS_HIDDEN\{| poll, no_smoke, defect |} [T= SPEC

assert SYS_HIDDEN\{| poll, no_smoke, defect |} [F= SPEC

assert SYS_HIDDEN\{| poll, no_smoke, defect |} [FD= SPEC



SPEC2 = comm?x.SMOKE -> alert -> comm?y.RESET -> if (y != x) then error -> STOP else SPEC2

--- tests if the system resets the sensor that caused the alarm ---
assert not SYS_HIDDEN\{| poll, no_smoke |} [F= SPEC2



SPEC3 = no_smoke -> SPEC3 -- useful?

--- tests if the specified behaviour is possible in concrete system ---
assert SYS_HIDDEN\{| poll |} [T= SPEC3

assert SYS_HIDDEN\{| poll |} [F= SPEC3

assert SYS_HIDDEN\{| poll |} [FD= SPEC3
