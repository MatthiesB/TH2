\documentclass[10pt,a4paper,fleqn]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[left=3.5cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage{fancyhdr}
\usepackage[ngerman]{babel}
\usepackage{amsfonts,amsmath}
\usepackage{cmbright}
\usepackage[usenames,dvipsnames]{color}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{enumitem}

\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;}

\lstset{
    language=Java,
    basicstyle=\ttfamily\small,
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    tabsize=2,
    showstringspaces=false,
    extendedchars=true,
    breaklines=true,
    showtabs=false,
    showspaces=false,
    keywordstyle=\color{green},
    commentstyle=\color{grey},
    stringstyle=\color{Blue},
    mathescape,
    escapechar=@,
    morekeywords={bool}
}

\begin{document}

  % Set defaults. (See docs/latex/templates/settings.tex)
  \renewcommand{\labelenumi}{(\alph{enumi})}
  \renewcommand\headrule{\vspace{+2pt}\hrule}
  \newcommand{\solved}{\[\hfill\Box\]}
  \setlength{\headheight}{2.5\baselineskip}
  \pagestyle{fancyplain}
  \pagenumbering{Roman}

  % Document header. (See docs/latex/templates/header.tex)
  \rhead{\emph{}\\ \today}
  \lhead{{\Large TH2 "Ubungszettel 4}\\ Bearbeitet von
  Jan Strothmann, Matthies Becker, \\Vitalij Kagadij \& Lotte Steenbrink}

  \section*{Projekt: Modellierung von Fehlern}
  \subsection*{a)}
  Mögliche Fehler:
  \begin{enumerate}[label=\arabic*.]
    \item Sensor sendet falsche Sensordaten (Fehlalarm, kein Alarm)
    \item Sensor reagiert nicht auf Poll (Totalausfall, Kabeldefekt)
    \item Sensor meldet Defekt
    \item Sensor lässt sich nicht resetten
    \item Controller fällt aus
    \item Controller wertet Daten falsch aus
  \end{enumerate}

  \subsection*{b)}
  Modellierte Fehler:
  \begin{enumerate}[label=\arabic*.]
    \item Da wir keine modllierte Umwelt haben, können wir ziwschen echtem und falschem Alarm nicht unterscheiden.
    \item Ohne Zeitmodellierung nicht modellierbar (Deadlock)
    \item Siehe Code
    \item Siehe Code
    \item Ohne Zeitmodellierung nicht modellierbar (Deadlock)
    \item Nicht modellierbar bzw nicht sinnvoll
  \end{enumerate}

  \subsection*{c)}
  Was können wir erkennen?
  \begin{enumerate}[label=\arabic*.]
    \item Nur mit Redundanzsensor
    \item Nur mit Zeitmodellierung
    \item Siehe Code
    \item Nur mit reset ACK und Zeitmodellierung
    \item Nur mit zeit UND watchdog-prozess ODER erkennung in den sensoren: zb: melder leuchten rot wenn controller nicht zurück ACKt
    \item Nicht zur Laufzeit feststellbar
  \end{enumerate}

  \section*{Projekt: Fehlertoleranz}
  \subsection*{a)}
    Siehe 1. c)

  \subsection*{b)}
  \begin{enumerate}[label=\arabic*.]
    \item Redundanz im Sensor: extra internal choice
    \item Mit timeout, bei timeout Service-Warnung
    \item Nachricht auf dem Kommunikationskanal -> Service-Warnung
    \item Mit Ack/timeout, bei timeout Service-Warnung
    \item timeout \& watchdog oder Erkennung durch Sensoren, bei Fehler Service-Warnung
    \item Gar nicht
  \end{enumerate}

  \section*{Theorie: Aufgabe 1}
  Siehe CSP-Datei.

  \section*{Theorie: Aufgabe 2}
  \subsection*{a)}
  Wissen laut traces-Definition für den Interupt:\\
  $traces(Stop \bigtriangleup P) = traces(Stop) \cup \{tr_1 \frown tr_2 | tr_1 \in traces(Stop) \wedge \checkmark \not\in \sigma(tr_1) \wedge tr_2 \in traces(P) \}$
\begin{align*}
\text{Unsere Werte einsetzen:}\\
&= \{<>\}\cup\{<>, P\}\\
\text{Nach Absorbptionsgesetz:}\\
&= \{<>, P\}\\
\text{Zusamenfassung nach prefix-Abgeschlossenheit (<> $\in$ traces(P)): }\\
&=\{tr(p)\}
\end{align*}
Somit wurde durch Umformen bewiesen, dass $Stop \bigtriangleup P =_T P$.

  \subsection*{b)}
Durch Einsetzen erhalten wir:\\
$\{tr | tr \in (traces(P)\cup traces(Q)) \wedge \checkmark \not\in \sigma(tr)\} \cup \{tr_1 \frown tr_2 | tr_1 \frown \checkmark \in (traces(P) \cup traces(Q))\wedge tr_2 \in traces(R) \} =
(\{tr | tr \in traces(P) \wedge \checkmark \not\in \sigma (tr)\} \cup \{tr_1 \frown tr_2 | tr_1 \frown \checkmark \in traces (P) \wedge tr_1 \in traces(R)\}) \cup (\{tr | tr \in traces(Q) \wedge \checkmark \in \sigma(tr)\} \cup \{tr_1 \frown tr_2 | tr_1 \frown \checkmark \in traces(Q) \wedge tr_1 \in traces(R)\})
$\\
Formen nun die linke Seite um, bis wir die rechte Seite bekommen.\\
$\{tr|tr \in traces(P) \wedge \checkmark \not\in \sigma(tr)\} \cup \{tr | tr \in traces(Q) \wedge \checkmark \not\in \sigma(tr)\} \cup \{tr_1 \frown tr_2 | tr_1 \frown \checkmark \in (traces(P) \cup(traces(Q)) \wedge tr_2 \in traces(R)\}
$\\
$= \{tr|tr \in traces(P) \wedge \checkmark \not\in \sigma(tr)\} \cup \{tr| tr \in traces(Q) \wedge \checkmark \not\in \sigma(tr)\} \cup \{tr_1 \frown tr_2 | tr_1 \frown \checkmark \in traces(P) \wedge tr_2 \in traces(R)\} \cup \{tr_1 \frown tr_2 | r_1 \frown \checkmark \in traces(Q) \wedge tr_2 \in traces(R)\}$
Dies lässt sich nun noch umsortieren, um den oberen rechten Term zu erhalten:\\
$= (\{tr | tr \in traces(P) \wedge \checkmark \not\in \sigma (tr)\} \cup \{tr_1 \frown tr_2 | tr_1 \frown \checkmark \in traces (P) \wedge tr_1 \in traces(R)\}) \cup (\{tr | tr \in traces(Q) \wedge \checkmark \in \sigma(tr)\} \cup \{tr_1 \frown tr_2 | tr_1 \frown \checkmark \in traces(Q) \wedge tr_1 \in traces(R)\})$
Somit wurde durch Umformen bewiesen, dass die Behauptung gilt.
\end{document}
